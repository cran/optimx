<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Safeguarded Newton algorithms</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Safeguarded Newton algorithms</h1>

<p>So-called <strong>Newton</strong> methods are among the most commonly mentioned in the 
solution of nonlinear
equations or function minimization. However, as discussed in </p>

<p><a href="https://en.wikipedia.org/wiki/Newton%27s_method#History">https://en.wikipedia.org/wiki/Newton%27s_method#History</a>,</p>

<p>the <strong>Newton</strong> or <strong>Newton-Raphson</strong> method as we know it today was not what either of its
supposed originators knew.</p>

<p>This vignette discusses the development of simple 
safeguarded variants of the Newton method for 
function minimization in <strong>R</strong>. Note that there are some resources in <strong>R</strong> for solving 
nonlinear equations by Newton-like methods in the packages <strong>nleqslv</strong> and <strong>pracma</strong>. </p>

<h1>The basic approach</h1>

<p>If we have a function \(f(x)\), with gradient \(g(x)\) and second derivative (Hessian) \(H(x)\)
the first order condition for an extremum (min or max) is  </p>

<p>\[g(x) = 0\]</p>

<p>To ensure a minimum, we want </p>

<p>\[ H(x) > 0 \]</p>

<p>The first order condition leads to a root-finding problem.</p>

<p>It turns out that \(x\) need not be a scalar. We can consider it to be a vector of 
parameters to be determined. This renders \(g(x)\) a vector also, and \(H(x)\) a matrix.
The conditions of optimality then require a zero gradient and positive-definite Hessian.</p>

<p>The Newton approach to such 
equations is to provide a guess to the root \(x_try\) and to then solve the equation</p>

<p>\[ H(x_t) * s = - g(x_t)\]</p>

<p>for the search vector \(s\). We update \(x_t\) to \(x_t + s\) and repeat until we have 
a very small gradient \(g(x_t)\). If \(H(x)\) is positive definite, we have a reasonable
approximation to a (local) minimum. </p>

<h1>Motivations</h1>

<p>A particular interest in Newton-like methods its theoretical quadratic convergence. See
<a href="https://en.wikipedia.org/wiki/Newton%27s_method">https://en.wikipedia.org/wiki/Newton%27s_method</a>.
That is, the method will converge in one step for a 
quadratic function \(f(x)\), and for &ldquo;reasonable&rdquo;
functions will converge very rapidly. There are, however, a number 
of conditions, and practical
programs need to include safequards against mis-steps in the iterations.</p>

<p>The principal issues concern the possiblity that \(H(x)\) may not 
be positive definite, at least
in some parts of the domain, and that the curvature may be such that a unit step \(x_t + s\)
does not reduce the function \(f\). We therefore get a number of possible variants of the 
method when different possible safeguards are applied.</p>

<h1>Algorithm possibilities</h1>

<p>There are many choices we can make in building a practical code to implement the ideas
above. In tandem with the two main issues expressed above, we will consider</p>

<ul>
<li><p>the modification of the solution of the main equation 
\[ H(x_t) * s = - g(x_t)\] so
that a reasonable search vector \(s\) is always generated by avoiding Hessian
matrices that are not positive definite. </p></li>
<li><p>the selection of a new set of parameters \(x_new = x_t + step * s\) so that the
function value \(f(x_new)\) is less than \(f(x_t)\).</p></li>
</ul>

<p>The second choice above could be made slightly more stringent so that the Armijo 
condition  of sufficient-decrease is met. 
Adding a curvature requirement gives the 
Wolfe condisions. See <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">https://en.wikipedia.org/wiki/Wolfe_conditions</a>. 
The Armijo requirement is generally written</p>

<p>\[f(x_t + step*s) < f(x_t) + c * step * g(x_t)^T*s\]</p>

<p>where c is some number less than 1. Typically \(c = 1e-4 = 0.0001\). Note that the product
of gradient times search vector is negative for any reasonable situation, since we are 
trying to go &ldquo;downhill&rdquo;.</p>

<p>As a result of the ideas in this section, the code <code>snewton()</code> uses a solution of
the Newton equations with the Hessian provided (if this is possible, else we stop),
along with a backtracking line search. The code <code>snewtonm</code> uses a Marquardt 
stabilization of the Hessian to create</p>

<p>\[ Haug = H + 1_n * lambda\]</p>

<p>That is, we add \(lambda\) times the unit matrix to \(H\). Then we try the set of parameters
found by adding the solution of the Newton equations with \(Haug\) in place of \(H\) to the
current &ldquo;best&rdquo; set of parameters. If this new set of parameters has a higher function
value than the &ldquo;best&rdquo; so far, we increase \(lambda\) and try again. Note that we do not
need to re-evaluate the gradient or Hessian to do this. Moreover, for some value of
\(lambda\), the step is clearly down the gradient (i.e., steepest descents) or we have
converged and no progress is possible. This leads to a very compact and elegant
code, which we name <code>snewtonm()</code> for Safeguarded Newton-Marquardt method. 
It is reliable, but may be less efficient than using the un-modified Hessian.</p>

<h1>A choice to compute the search vector</h1>

<p>The primary concern in solving for \(s\) is that the Hessian may not be positive definite. 
This means that we cannot apply fast and stable methods like the Cholesky decomposition
to the matrix. At the time of writing, we use the following approach:</p>

<ul>
<li><p>We attempt to solve </p>

<p>\[ H(x_t) * s = - g(x_t)\]
with <strong>R</strong> directly, and rely on internal
checks to catch any cases where the solution fails. We then use <code>try()</code> to stop the
program in this case.</p></li>
</ul>

<h1>Choosing the step size</h1>

<p>The traditional Newton approach is that the stepsize is taken to be 1. In practice,
this can sometimes mean that the function value is not reduced. As an alternative,
we can use a simple backtrack search. We start with \(step = 1\) (actually the program 
allows for the element <code>defstep</code> of the <code>control</code> list to be set to a value other
than 1). If the Armijo condition is not met, we replace \(step\) with $ r * step $ 
where \(r\) is less than 1. Here we suggest <code>control$stepdec = 0.2</code>. We repeat until 
\(x_t\) satisfies the Armijo condition or \(x_t\) is essentially unchanged by the step.</p>

<p>Here &ldquo;essentially unchanged&rdquo; is determined by a test using an offset value, that is,
the test </p>

<p>\[   (x_t + offset) == (x_t + step * d + offset) \]</p>

<p>where \(d\) is the search direction. <code>control$offset = 100</code> is used. We could
also, and almost equivalently, use the <strong>R</strong> <code>identical</code> function.</p>

<p>This approach has been coded into the <code>snewton()</code> function.</p>

<h1>Examples</h1>

<p>These examples are coded as a test to the interim package <strong>snewton</strong>, but as
at 2018-7-10 are part of the <code>optimx</code> package. We call these below mostly via
the <code>optimr()</code> function to allow compact output to be used, but please note that
some count information on the number of hessian evaluations and &ldquo;iterations&rdquo; (which
generally is an algorithm-specific measure) is not then returned.</p>

<h2>A simple example</h2>

<p>The following example is trivial, in that the Hessian is a constant matrix,
and we achieve convergence immediately.</p>

<pre><code class="r">x0&lt;-c(1,2,3,4)
fnt &lt;- function(x, fscale=10){
  yy &lt;- length(x):1
  val &lt;- sum((yy*x)^2)*fscale
}
grt &lt;- function(x, fscale=10){
  nn &lt;- length(x)
  yy &lt;- nn:1
  #    gg &lt;- rep(NA,nn)
  gg &lt;- 2*(yy^2)*x*fscale
  gg
}

hesst &lt;- function(x, fscale=10){
  nn &lt;- length(x)
  yy &lt;- nn:1
  hh &lt;- diag(2*yy^2*fscale)
  hh
}

require(optimx)
t1 &lt;- snewton(x0, fnt, grt, hesst, control=list(trace=0), fscale=3.0)
print(t1)
</code></pre>

<pre><code>## $par
## [1] 0 0 0 0
## 
## $value
## [1] 0
## 
## $grad
## [1] 0 0 0 0
## 
## $Hess
##      [,1] [,2] [,3] [,4]
## [1,]   96    0    0    0
## [2,]    0   54    0    0
## [3,]    0    0   24    0
## [4,]    0    0    0    6
## 
## $counts
## $counts$niter
## [1] 2
## 
## $counts$nfn
## [1] 2
## 
## $counts$ngr
## [1] 2
## 
## $counts$nhess
## [1] 1
## 
## 
## $convcode
## [1] 0
## 
## $message
## [1] &quot;Small gradient norm&quot;
</code></pre>

<pre><code class="r"># we can also use nlm and nlminb
fght &lt;- function(x, fscale=10){
  ## combine f, g and h into single function for nlm
     ff &lt;- fnt(x, fscale)
     gg &lt;- grt(x, fscale)
     hh &lt;- hesst(x, fscale)
     attr(ff, &quot;gradient&quot;) &lt;- gg
     attr(ff, &quot;hessian&quot;) &lt;- hh
     ff
}

t1nlm &lt;- nlm(fght, x0, fscale=3.0, hessian=TRUE, print.level=0)
print(t1nlm)
</code></pre>

<pre><code>## $minimum
## [1] 1.232595e-29
## 
## $estimate
## [1] 0.000000e+00 2.220446e-16 4.440892e-16 0.000000e+00
## 
## $gradient
## [1] 0.000000e+00 3.996803e-14 3.552714e-14 0.000000e+00
## 
## $hessian
##              [,1] [,2] [,3]         [,4]
## [1,] 3.200000e+02    0    0 4.235165e-14
## [2,] 0.000000e+00  180    0 0.000000e+00
## [3,] 0.000000e+00    0   80 0.000000e+00
## [4,] 4.235165e-14    0    0 2.000000e+01
## 
## $code
## [1] 1
## 
## $iterations
## [1] 1
</code></pre>

<pre><code class="r">## BUT ... it looks like nlminb is NOT using a true Newton-type method
t1nlminb &lt;- nlminb(x0, fnt, gradient=grt, hessian=hesst, fscale=3.0, 
                   control=list(trace=0))
print(t1nlminb)
</code></pre>

<pre><code>## $par
## [1] -4.043175e-174   0.000000e+00 -3.234540e-173 -1.293816e-172
## 
## $objective
## [1] 0
## 
## $convergence
## [1] 0
## 
## $iterations
## [1] 13
## 
## $evaluations
## function gradient 
##       15       13 
## 
## $message
## [1] &quot;relative convergence (4)&quot;
</code></pre>

<pre><code class="r"># and call them from optimx (i.e., test this gives same results)
t1so &lt;-  optimr(x0, fnt, grt, hess=hesst, method=&quot;snewton&quot;, fscale=3.0, 
                 control=list(trace=0))
proptimr(t1so)
</code></pre>

<pre><code>## Result  t1so   proposes optimum function value = 0  at parameters
## [1] 0 0 0 0
## After  2  fn evals, and  2  gr evals
## Termination code is  0 : Small gradient norm
## ---------------------------------------
</code></pre>

<pre><code class="r">t1nlmo &lt;- optimr(x0, fnt, grt, hess=hesst, method=&quot;nlm&quot;, fscale=3.0, 
                 control=list(trace=0))
proptimr(t1nlmo)
</code></pre>

<pre><code>## Result  t1nlmo   proposes optimum function value = 1.232595e-29  at parameters
## [1] 0.000000e+00 2.220446e-16 4.440892e-16 0.000000e+00
## After  NA  fn evals, and  1  gr evals
## Termination code is  0 : nlm: Convergence indicator (code) =  1
## ---------------------------------------
</code></pre>

<pre><code class="r">tst &lt;- try(t1nlminbo &lt;- optimr(x0, fnt, grt, hess=hesst, method=&quot;nlminb&quot;, 
                               fscale=3.0, control=list(trace=0)))
if (class(tst) == &quot;try-error&quot;){
    cat(&quot;try-error on attempt to run nlminb in optimr()\n&quot;)
} else { proptimr(t1nlminbo) }
</code></pre>

<pre><code>## Result  t1nlminbo   proposes optimum function value = 0  at parameters
## [1] -4.043175e-174   0.000000e+00 -3.234540e-173 -1.293816e-172
## After  15  fn evals, and  13  gr evals
## Termination code is  0 : relative convergence (4)
## ---------------------------------------
</code></pre>

<p>From the number of function and gradient evaluations, it appears <code>nlminb()</code> is not
using the Hessian information. Note that the <code>snewton()</code> and <code>snewtonm()</code> functions
return count information for iterations and hessian evaluations, but these are not
part of the standard <code>optim()</code> (and thus <code>optimr()</code>) result objects.</p>

<h2>The Rosenbrock function</h2>

<pre><code class="r">require(optimx)
#Rosenbrock banana valley function
f &lt;- function(x){
return(100*(x[2] - x[1]*x[1])^2 + (1-x[1])^2)
}
#gradient
gr &lt;- function(x){
return(c(-400*x[1]*(x[2] - x[1]*x[1]) - 2*(1-x[1]), 200*(x[2] - x[1]*x[1])))
}
#Hessian
h &lt;- function(x) {
a11 &lt;- 2 - 400*x[2] + 1200*x[1]*x[1]; a21 &lt;- -400*x[1]
return(matrix(c(a11, a21, a21, 200), 2, 2))
}
x0 &lt;- c(-1.2, 1)
# sink(&quot;mbrn1-170408.txt&quot;, split=TRUE)
t1 &lt;- snewton(x0, fn=f, gr=gr, hess=h, control=list(trace=0))
print(t1)
</code></pre>

<pre><code>## $par
## [1] 1 1
## 
## $value
## [1] 0
## 
## $grad
## [1] 0 0
## 
## $Hess
##      [,1] [,2]
## [1,]  802 -400
## [2,] -400  200
## 
## $counts
## $counts$niter
## [1] 25
## 
## $counts$nfn
## [1] 33
## 
## $counts$ngr
## [1] 25
## 
## $counts$nhess
## [1] 24
## 
## 
## $convcode
## [1] 0
## 
## $message
## [1] &quot;Small gradient norm&quot;
</code></pre>

<pre><code class="r"># we can also use nlm and nlminb
fght &lt;- function(x){
  ## combine f, g and h into single function for nlm
     ff &lt;- f(x)
     gg &lt;- gr(x)
     hh &lt;- h(x)
     attr(ff, &quot;gradient&quot;) &lt;- gg
     attr(ff, &quot;hessian&quot;) &lt;- hh
     ff
}

# COULD TRY: t1nlm &lt;- nlm(fght, x0, hessian=TRUE, print.level=2, iterlim=10000)
t1nlmo &lt;- optimr(x0, f, gr, hess=h, method=&quot;nlm&quot;, control=list(trace=0))
proptimr(t1nlmo)
</code></pre>

<pre><code>## Result  t1nlmo   proposes optimum function value = 1.127026e-17  at parameters
## [1] 1 1
## After  NA  fn evals, and  24  gr evals
## Termination code is  0 : nlm: Convergence indicator (code) =  1
## ---------------------------------------
</code></pre>

<pre><code class="r">t1so &lt;- optimr(x0, f, gr, hess=h, method=&quot;snewton&quot;, control=list(trace=0))
proptimr(t1so)
</code></pre>

<pre><code>## Result  t1so   proposes optimum function value = 0  at parameters
## [1] 1 1
## After  33  fn evals, and  25  gr evals
## Termination code is  0 : Small gradient norm
## ---------------------------------------
</code></pre>

<pre><code class="r">t1smo &lt;-  optimr(x0, f, gr, hess=h, method=&quot;snewtonm&quot;, control=list(trace=0))
</code></pre>

<pre><code>## Small gradient
</code></pre>

<pre><code class="r">proptimr(t1smo)
</code></pre>

<pre><code>## Result  t1smo   proposes optimum function value = 0  at parameters
## [1] 1 1
## After  46  fn evals, and  28  gr evals
## Termination code is  0 : snewtonm: Normal exit
## ---------------------------------------
</code></pre>

<pre><code class="r">## Again, nlminb probably not using hessian
tst &lt;- try(t1nlminbo &lt;- optimr(x0, f, gr, hess=h, method=&quot;nlminb&quot;, 
                               control=list(trace=0)))
if (class(tst) == &quot;try-error&quot;){
    cat(&quot;try-error on attempt to run nlminb in optimr()\n&quot;)
} else { proptimr(t1nlminbo) }
</code></pre>

<pre><code>## Result  t1nlminbo   proposes optimum function value = 0  at parameters
## [1] 1 1
## After  33  fn evals, and  26  gr evals
## Termination code is  0 : X-convergence (3)
## ---------------------------------------
</code></pre>

<h2>The Wood function</h2>

<p>For <code>nlm()</code> the &ldquo;standard&rdquo; start takes more than 100 iterations and returns
a non-optimal solution.</p>

<pre><code class="r">#Example: Wood function
#
wood.f &lt;- function(x){
  res &lt;- 100*(x[1]^2-x[2])^2+(1-x[1])^2+90*(x[3]^2-x[4])^2+(1-x[3])^2+
    10.1*((1-x[2])^2+(1-x[4])^2)+19.8*(1-x[2])*(1-x[4])
  return(res)
}
#gradient:
wood.g &lt;- function(x){
  g1 &lt;- 400*x[1]^3-400*x[1]*x[2]+2*x[1]-2
  g2 &lt;- -200*x[1]^2+220.2*x[2]+19.8*x[4]-40
  g3 &lt;- 360*x[3]^3-360*x[3]*x[4]+2*x[3]-2
  g4 &lt;- -180*x[3]^2+200.2*x[4]+19.8*x[2]-40
  return(c(g1,g2,g3,g4))
}
#hessian:
wood.h &lt;- function(x){
  h11 &lt;- 1200*x[1]^2-400*x[2]+2;    h12 &lt;- -400*x[1]; h13 &lt;- h14 &lt;- 0
  h22 &lt;- 220.2; h23 &lt;- 0;    h24 &lt;- 19.8
  h33 &lt;- 1080*x[3]^2-360*x[4]+2;    h34 &lt;- -360*x[3]
  h44 &lt;- 200.2
  H &lt;- matrix(c(h11,h12,h13,h14,h12,h22,h23,h24,
                h13,h23,h33,h34,h14,h24,h34,h44),ncol=4)
  return(H)
}

wood.fgh &lt;- function(x){
      fval &lt;- wood.f(x)
      gval &lt;- wood.g(x)
      hval &lt;- wood.h(x)
      attr(fval,&quot;gradient&quot;) &lt;- gval
      attr(fval,&quot;hessian&quot;)&lt;- hval
      fval
}

#################################################
x0 &lt;- c(-3,-1,-3,-1) # Wood standard start

require(optimx)
# In 100 iterations, not converged
t1nlm &lt;- nlm(wood.fgh, x0, print.level=0)
print(t1nlm)
</code></pre>

<pre><code>## $minimum
## [1] 7.874467
## 
## $estimate
## [1] -1.0316067  1.0740774 -0.9012710  0.8239815
## 
## $gradient
## [1]  0.007517820 -0.015797320 -0.008937001  0.015745111
## 
## $code
## [1] 4
## 
## $iterations
## [1] 100
</code></pre>

<pre><code class="r"># But both newton approaches do work
wd &lt;- snewton(x0, fn=wood.f, gr=wood.g, hess=wood.h, control=list(trace=0))
print(wd)
</code></pre>

<pre><code>## $par
## [1] 1 1 1 1
## 
## $value
## [1] 1.142616e-29
## 
## $grad
## [1] -2.442491e-15 -7.105427e-15  3.108624e-15  0.000000e+00
## 
## $Hess
##      [,1]   [,2] [,3]   [,4]
## [1,]  802 -400.0    0    0.0
## [2,] -400  220.2    0   19.8
## [3,]    0    0.0  722 -360.0
## [4,]    0   19.8 -360  200.2
## 
## $counts
## $counts$niter
## [1] 70
## 
## $counts$nfn
## [1] 119
## 
## $counts$ngr
## [1] 70
## 
## $counts$nhess
## [1] 70
## 
## 
## $convcode
## [1] 92
## 
## $message
## [1] &quot;No progress before linesearch!&quot;
</code></pre>

<pre><code class="r">wdm &lt;- snewtonm(x0, fn=wood.f, gr=wood.g, hess=wood.h, control=list(trace=0))
print(wdm)
</code></pre>

<pre><code>## $par
## [1] 1 1 1 1
## 
## $value
## [1] 1.399599e-28
## 
## $grad
## [1] -1.243450e-14  3.552714e-14  1.243450e-14  0.000000e+00
## 
## $Hess
##      [,1]   [,2] [,3]   [,4]
## [1,]  802 -400.0    0    0.0
## [2,] -400  220.2    0   19.8
## [3,]    0    0.0  722 -360.0
## [4,]    0   19.8 -360  200.2
## 
## $counts
## $counts$niter
## [1] 89
## 
## $counts$nfn
## [1] 88
## 
## $counts$ngr
## [1] 50
## 
## $counts$nhess
## [1] 50
## 
## 
## $convcode
## [1] 0
## 
## $message
## [1] &quot;snewtonm: Normal exit&quot;
</code></pre>

<pre><code class="r">## AND again nlminb not likely using hessian information
## t1nlminb &lt;- nlminb(x0, wood.f, gradient=wood.g, hess=wood.h, control=list(trace=0))
## print(t1nlminb)
# and call them from optimx (i.e., test this gives same results)

# But optimr uses a larger iteration limit, and gets to solution
t1nlmo &lt;- optimr(x0, wood.f, wood.g, hess=wood.h, method=&quot;nlm&quot;, control=list(trace=0))
proptimr(t1nlmo)
</code></pre>

<pre><code>## Result  t1nlmo   proposes optimum function value = 1.004943e-16  at parameters
## [1] 1 1 1 1
## After  NA  fn evals, and  335  gr evals
## Termination code is  0 : nlm: Convergence indicator (code) =  1
## ---------------------------------------
</code></pre>

<pre><code class="r">tst&lt;-try(t1nlminbo &lt;- optimr(x0, wood.f, wood.g, hess=wood.h, method=&quot;nlminb&quot;, control=list(trace=0)))
if (class(tst) == &quot;try-error&quot;){
    cat(&quot;try-error on attempt to run nlminb in optimr()\n&quot;)
} else { proptimr(t1nlminbo) }
</code></pre>

<pre><code>## Result  t1nlminbo   proposes optimum function value = 4.79233e-29  at parameters
## [1] 1 1 1 1
## After  56  fn evals, and  45  gr evals
## Termination code is  0 : X-convergence (3)
## ---------------------------------------
</code></pre>

<h2>A generalized Rosenbrock function</h2>

<p>There are several generalizations of the Rosenbrock function (??ref)</p>

<pre><code class="r"># genrosa function code -- attempts to match the rosenbrock at gs=100 and x=c(-1.2,1)
genrosa.f&lt;- function(x, gs=NULL){ # objective function
## One generalization of the Rosenbrock banana valley function (n parameters)
    n &lt;- length(x)
        if(is.null(gs)) { gs=100.0 }
        # Note do not at 1.0 so min at 0
    fval&lt;-sum (gs*(x[1:(n-1)]^2 - x[2:n])^2 + (x[1:(n-1)] - 1)^2)
}

genrosa.g &lt;- function(x, gs=NULL){
# vectorized gradient for genrose.f
# Ravi Varadhan 2009-04-03
    n &lt;- length(x)
        if(is.null(gs)) { gs=100.0 }
    gg &lt;- as.vector(rep(0, n))
    tn &lt;- 2:n
    tn1 &lt;- tn - 1
    z1 &lt;- x[tn] - x[tn1]^2
    z2 &lt;- 1 - x[tn1]
        # f = gs*z1*z1 + z2*z2
    gg[tn] &lt;- 2 * (gs * z1)
    gg[tn1] &lt;- gg[tn1] - 4 * gs * x[tn1] * z1 - 2 *z2 
    return(gg)
}

genrosa.h &lt;- function(x, gs=NULL) { ## compute Hessian
   if(is.null(gs)) { gs=100.0 }
    n &lt;- length(x)
    hh&lt;-matrix(rep(0, n*n),n,n)
    for (i in 2:n) {
        z1&lt;-x[i]-x[i-1]*x[i-1]
#       z2&lt;-1.0 - x[i-1]
                hh[i,i]&lt;-hh[i,i]+2.0*(gs+1.0)
                hh[i-1,i-1]&lt;-hh[i-1,i-1]-4.0*gs*z1-4.0*gs*x[i-1]*(-2.0*x[i-1])
                hh[i,i-1]&lt;-hh[i,i-1]-4.0*gs*x[i-1]
                hh[i-1,i]&lt;-hh[i-1,i]-4.0*gs*x[i-1]
    }
        return(hh)
}

require(optimx)
cat(&quot;Generalized Rosenbrock tests\n&quot;)
</code></pre>

<pre><code>## Generalized Rosenbrock tests
</code></pre>

<pre><code class="r">cat(&quot;original n and x0&quot;)
</code></pre>

<pre><code>## original n and x0
</code></pre>

<pre><code class="r">x0 &lt;- c(-1.2, 1)
solorig &lt;- snewton(x0, genrosa.f, genrosa.g, genrosa.h)
print(solorig)
</code></pre>

<pre><code>## $par
## [1] 1 1
## 
## $value
## [1] 2.972526e-28
## 
## $grad
## [1]  5.462297e-14 -4.440892e-14
## 
## $Hess
##      [,1] [,2]
## [1,]  800 -400
## [2,] -400  202
## 
## $counts
## $counts$niter
## [1] 128
## 
## $counts$nfn
## [1] 143
## 
## $counts$ngr
## [1] 128
## 
## $counts$nhess
## [1] 128
## 
## 
## $convcode
## [1] 92
## 
## $message
## [1] &quot;No progress before linesearch!&quot;
</code></pre>

<pre><code class="r">print(eigen(solorig$Hess)$values)
</code></pre>

<pre><code>## [1] 1000.400641    1.599359
</code></pre>

<pre><code class="r">solorigm &lt;- snewtonm(x0, genrosa.f, genrosa.g, genrosa.h)
print(solorigm)
</code></pre>

<pre><code>## $par
## [1] 1 1
## 
## $value
## [1] 1.232595e-30
## 
## $grad
## [1] -2.220446e-15  0.000000e+00
## 
## $Hess
##      [,1] [,2]
## [1,]  800 -400
## [2,] -400  202
## 
## $counts
## $counts$niter
## [1] 152
## 
## $counts$nfn
## [1] 151
## 
## $counts$ngr
## [1] 132
## 
## $counts$nhess
## [1] 132
## 
## 
## $convcode
## [1] 0
## 
## $message
## [1] &quot;snewtonm: Normal exit&quot;
</code></pre>

<pre><code class="r">print(eigen(solorigm$Hess)$values)
</code></pre>

<pre><code>## [1] 1000.400641    1.599359
</code></pre>

<pre><code class="r">cat(&quot;Start with 50 values of pi and scale factor 10\n&quot;)
</code></pre>

<pre><code>## Start with 50 values of pi and scale factor 10
</code></pre>

<pre><code class="r">x0 &lt;- rep(pi, 50)
sol50pi &lt;- optimr(x0, genrosa.f, genrosa.g, genrosa.h, method=&quot;snewton&quot;, gs=10)
proptimr(sol50pi)
</code></pre>

<pre><code>## Result  sol50pi   proposes optimum function value = 6.108742e-29  at parameters
##  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## [36] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## After  145  fn evals, and  145  gr evals
## Termination code is  92 : No progress before linesearch!
## ---------------------------------------
</code></pre>

<pre><code class="r">hhi &lt;- genrosa.h(sol50pi$par, gs=10)
print(eigen(hhi)$values)
</code></pre>

<pre><code>##  [1] 181.84200 181.36863 180.58176 179.48449 178.08116 176.37730 174.37964
##  [8] 172.09607 169.53560 166.70834 163.62545 160.29911 156.74243 152.96948
## [15] 148.99513 144.83509 140.50578 136.02429 131.40832 126.67610 121.84632
## [22] 116.93804 111.97066 106.96381 101.93725  96.91085  91.90447  86.93791
## [29]  82.03080  77.20253  72.47223  67.85859  63.37989  59.05387  54.89766
## [36]  50.92776  47.15992  43.60907  40.28933  37.21385  34.39481  31.84332
## [43]  29.56937  27.58175  25.88797  24.49427  23.40556  22.62547  22.15648
## [50]   2.00000
</code></pre>

<pre><code class="r">sol50pim &lt;- optimr(x0, genrosa.f, genrosa.g, genrosa.h, method=&quot;snewtonm&quot;, gs=10)
proptimr(sol50pim)
</code></pre>

<pre><code>## Result  sol50pim   proposes optimum function value = 1.528418e-30  at parameters
##  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## [36] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## After  157  fn evals, and  152  gr evals
## Termination code is  0 : snewtonm: Normal exit
## ---------------------------------------
</code></pre>

<pre><code class="r">hhm &lt;- genrosa.h(sol50pim$par, gs=10)
print(eigen(hhm)$values)
</code></pre>

<pre><code>##  [1] 181.84200 181.36863 180.58176 179.48449 178.08116 176.37730 174.37964
##  [8] 172.09607 169.53560 166.70834 163.62545 160.29911 156.74243 152.96948
## [15] 148.99513 144.83509 140.50578 136.02429 131.40832 126.67610 121.84632
## [22] 116.93804 111.97066 106.96381 101.93725  96.91085  91.90447  86.93791
## [29]  82.03080  77.20253  72.47223  67.85859  63.37989  59.05387  54.89766
## [36]  50.92776  47.15992  43.60907  40.28933  37.21385  34.39481  31.84332
## [43]  29.56937  27.58175  25.88797  24.49427  23.40556  22.62547  22.15648
## [50]   2.00000
</code></pre>

<h2>The Hobbs weed infestation problem</h2>

<p>This problem is described in @cnm79. It has various nasty properties. Note that one starting point causes
failure of the <code>snewton()</code> optimizer.</p>

<pre><code class="r">## Optimization test function HOBBS
## ?? refs (put in .doc??)
## Nash and Walker-Smith (1987, 1989) ...
require(optimx)

hobbs.f&lt;- function(x){ # # Hobbs weeds problem -- function
    if (abs(12*x[3]) &gt; 500) { # check computability
       fbad&lt;-.Machine$double.xmax
       return(fbad)
    }
    res&lt;-hobbs.res(x)
    f&lt;-sum(res*res)
}


hobbs.res&lt;-function(x){ # Hobbs weeds problem -- residual
# This variant uses looping
    if(length(x) != 3) stop(&quot;hobbs.res -- parameter vector n!=3&quot;)
    y&lt;-c(5.308, 7.24, 9.638, 12.866, 17.069, 23.192, 31.443, 38.558, 50.156, 62.948,
         75.995, 91.972)
    t&lt;-1:12
    if(abs(12*x[3])&gt;50) {
       res&lt;-rep(Inf,12)
    } else {
       res&lt;-x[1]/(1+x[2]*exp(-x[3]*t)) - y
    }
}

hobbs.jac&lt;-function(x){ # Jacobian of Hobbs weeds problem
   jj&lt;-matrix(0.0, 12, 3)
   t&lt;-1:12
    yy&lt;-exp(-x[3]*t)
    zz&lt;-1.0/(1+x[2]*yy)
     jj[t,1] &lt;- zz
     jj[t,2] &lt;- -x[1]*zz*zz*yy
     jj[t,3] &lt;- x[1]*zz*zz*yy*x[2]*t
   return(jj)
}

hobbs.g&lt;-function(x){ # gradient of Hobbs weeds problem
    # NOT EFFICIENT TO CALL AGAIN
    jj&lt;-hobbs.jac(x)
    res&lt;-hobbs.res(x)
    gg&lt;-as.vector(2.*t(jj) %*% res)
    return(gg)
}


hobbs.rsd&lt;-function(x) { # Jacobian second derivative
    rsd&lt;-array(0.0, c(12,3,3))
    t&lt;-1:12
    yy&lt;-exp(-x[3]*t)
    zz&lt;-1.0/(1+x[2]*yy)
    rsd[t,1,1]&lt;- 0.0
    rsd[t,2,1]&lt;- -yy*zz*zz
    rsd[t,1,2]&lt;- -yy*zz*zz
    rsd[t,2,2]&lt;- 2.0*x[1]*yy*yy*zz*zz*zz
    rsd[t,3,1]&lt;- t*x[2]*yy*zz*zz
    rsd[t,1,3]&lt;- t*x[2]*yy*zz*zz
    rsd[t,3,2]&lt;- t*x[1]*yy*zz*zz*(1-2*x[2]*yy*zz)
    rsd[t,2,3]&lt;- t*x[1]*yy*zz*zz*(1-2*x[2]*yy*zz)
##    rsd[t,3,3]&lt;- 2*t*t*x[1]*x[2]*x[2]*yy*yy*zz*zz*zz
    rsd[t,3,3]&lt;- -t*t*x[1]*x[2]*yy*zz*zz*(1-2*yy*zz*x[2])
    return(rsd)
}


hobbs.h &lt;- function(x) { ## compute Hessian
#   cat(&quot;Hessian not yet available\n&quot;)
#   return(NULL)
    H&lt;-matrix(0,3,3)
    res&lt;-hobbs.res(x)
    jj&lt;-hobbs.jac(x)
    rsd&lt;-hobbs.rsd(x)
##    H&lt;-2.0*(t(res) %*% rsd + t(jj) %*% jj)
    for (j in 1:3) {
       for (k in 1:3) {
          for (i in 1:12) {
             H[j,k]&lt;-H[j,k]+res[i]*rsd[i,j,k]
          }
       }
    }
    H&lt;-2*(H + t(jj) %*% jj)
    return(H)
}

require(optimx)
x0 &lt;- c(200, 50, .3)
cat(&quot;Start for Hobbs:&quot;)
</code></pre>

<pre><code>## Start for Hobbs:
</code></pre>

<pre><code class="r">print(x0)
</code></pre>

<pre><code>## [1] 200.0  50.0   0.3
</code></pre>

<pre><code class="r">solx0 &lt;- snewton(x0, hobbs.f, hobbs.g, hobbs.h)
## Note that we exceed count limit, but have answer
print(solx0)
</code></pre>

<pre><code>## $par
## [1] 196.1862618  49.0916395   0.3135697
## 
## $value
## [1] 2.587277
## 
## $grad
## [1]  5.101475e-14 -1.320055e-13  6.343726e-11
## 
## $Hess
##             [,1]         [,2]        [,3]
## [1,]    1.265461    -3.256125    1602.105
## [2,]   -3.256125     8.627095   -4095.206
## [3,] 1602.105263 -4095.206388 2043434.033
## 
## $counts
## $counts$niter
## [1] 501
## 
## $counts$nfn
## [1] 501
## 
## $counts$ngr
## [1] 501
## 
## $counts$nhess
## [1] 500
## 
## 
## $convcode
## [1] 1
## 
## $message
## [1] &quot;Snewton - no msg&quot;
</code></pre>

<pre><code class="r">print(eigen(solx0$Hess)$values)
</code></pre>

<pre><code>## [1] 2.043443e+06 4.249248e-01 4.413953e-03
</code></pre>

<pre><code class="r">## Note that we exceed count limit, but have answer

## Setting relative check offset larger gets quicker convergence
solx0a &lt;- snewton(x0, hobbs.f, hobbs.g, hobbs.h, control=list(offset=1000.))
print(solx0a)
</code></pre>

<pre><code>## $par
## [1] 196.1862618  49.0916395   0.3135697
## 
## $value
## [1] 2.587277
## 
## $grad
## [1] -1.071365e-14  2.819966e-14 -1.364242e-11
## 
## $Hess
##             [,1]         [,2]        [,3]
## [1,]    1.265461    -3.256125    1602.105
## [2,]   -3.256125     8.627095   -4095.206
## [3,] 1602.105263 -4095.206388 2043434.033
## 
## $counts
## $counts$niter
## [1] 13
## 
## $counts$nfn
## [1] 13
## 
## $counts$ngr
## [1] 13
## 
## $counts$nhess
## [1] 13
## 
## 
## $convcode
## [1] 92
## 
## $message
## [1] &quot;No progress before linesearch!&quot;
</code></pre>

<pre><code class="r">x1s &lt;- c(100, 10, .1)
cat(&quot;Start for Hobbs:&quot;)
</code></pre>

<pre><code>## Start for Hobbs:
</code></pre>

<pre><code class="r">print(x1s)
</code></pre>

<pre><code>## [1] 100.0  10.0   0.1
</code></pre>

<pre><code class="r">solx1s &lt;- snewton(x1s, hobbs.f, hobbs.g, hobbs.h, control=list(trace=0))
print(solx1s)
</code></pre>

<pre><code>## $par
## [1] 196.1862618  49.0916395   0.3135697
## 
## $value
## [1] 2.587277
## 
## $grad
## [1]  4.268808e-14 -1.088019e-13  5.439915e-11
## 
## $Hess
##             [,1]         [,2]        [,3]
## [1,]    1.265461    -3.256125    1602.105
## [2,]   -3.256125     8.627095   -4095.206
## [3,] 1602.105263 -4095.206388 2043434.033
## 
## $counts
## $counts$niter
## [1] 22
## 
## $counts$nfn
## [1] 31
## 
## $counts$ngr
## [1] 22
## 
## $counts$nhess
## [1] 22
## 
## 
## $convcode
## [1] 92
## 
## $message
## [1] &quot;No progress before linesearch!&quot;
</code></pre>

<pre><code class="r">print(eigen(solx1s$Hess)$values)
</code></pre>

<pre><code>## [1] 2.043443e+06 4.249248e-01 4.413953e-03
</code></pre>

<pre><code class="r">solx1m &lt;- snewton(x1s, hobbs.f, hobbs.g, hobbs.h, control=list(trace=0))
print(solx1m)
</code></pre>

<pre><code>## $par
## [1] 196.1862618  49.0916395   0.3135697
## 
## $value
## [1] 2.587277
## 
## $grad
## [1]  4.268808e-14 -1.088019e-13  5.439915e-11
## 
## $Hess
##             [,1]         [,2]        [,3]
## [1,]    1.265461    -3.256125    1602.105
## [2,]   -3.256125     8.627095   -4095.206
## [3,] 1602.105263 -4095.206388 2043434.033
## 
## $counts
## $counts$niter
## [1] 22
## 
## $counts$nfn
## [1] 31
## 
## $counts$ngr
## [1] 22
## 
## $counts$nhess
## [1] 22
## 
## 
## $convcode
## [1] 92
## 
## $message
## [1] &quot;No progress before linesearch!&quot;
</code></pre>

<pre><code class="r">print(eigen(solx1m$Hess)$values)
</code></pre>

<pre><code>## [1] 2.043443e+06 4.249248e-01 4.413953e-03
</code></pre>

<pre><code class="r">cat(&quot;Following test fails in snewton with ERROR -- Why?\n&quot;)
</code></pre>

<pre><code>## Following test fails in snewton with ERROR -- Why?
</code></pre>

<pre><code class="r">x3 &lt;- c(1, 1, 1)
cat(&quot;Start for Hobbs:&quot;)
</code></pre>

<pre><code>## Start for Hobbs:
</code></pre>

<pre><code class="r">print(x3)
</code></pre>

<pre><code>## [1] 1 1 1
</code></pre>

<pre><code class="r">ftest &lt;- try(solx3 &lt;- snewton(x3, hobbs.f, hobbs.g, hobbs.h, control=list(trace=0)))
if (class(ftest) != &quot;try-error&quot;) {
   print(solx3)
   print(eigen(solx3$Hess)$values)
}
</code></pre>

<pre><code>## $par
## [1] 1 1 1
## 
## $value
## [1] 23520.58
## 
## $grad
## [1] -824.042084    4.764888  -11.025384
## 
## $Hess
##           [,1]      [,2]      [,3]
## [1,] 22.321687  4.150703 -9.853740
## [2,]  4.150703 -1.275310 -9.255147
## [3,] -9.853740 -9.255147 33.506883
## 
## $counts
## $counts$niter
## [1] 1
## 
## $counts$nfn
## [1] 2
## 
## $counts$ngr
## [1] 1
## 
## $counts$nhess
## [1] 1
## 
## 
## $convcode
## [1] 9999
## 
## $message
## [1] &quot;snewton: New function value infinite&quot;
## 
## [1] 41.618914 16.635191 -3.700846
</code></pre>

<pre><code class="r">cat(&quot;But Marquardt variant succeeds\n&quot;)
</code></pre>

<pre><code>## But Marquardt variant succeeds
</code></pre>

<pre><code class="r">solx3m &lt;- snewtonm(x3, hobbs.f, hobbs.g, hobbs.h, control=list(trace=0))
print(solx3m)
</code></pre>

<pre><code>## $par
## [1] 196.1862618  49.0916395   0.3135697
## 
## $value
## [1] 2.587277
## 
## $grad
## [1] -2.675637e-14  6.739054e-14 -3.473133e-11
## 
## $Hess
##             [,1]         [,2]        [,3]
## [1,]    1.265461    -3.256125    1602.105
## [2,]   -3.256125     8.627095   -4095.206
## [3,] 1602.105263 -4095.206388 2043434.033
## 
## $counts
## $counts$niter
## [1] 49
## 
## $counts$nfn
## [1] 48
## 
## $counts$ngr
## [1] 28
## 
## $counts$nhess
## [1] 28
## 
## 
## $convcode
## [1] 0
## 
## $message
## [1] &quot;snewtonm: Normal exit&quot;
</code></pre>

<pre><code class="r">print(eigen(solx3m$Hess)$values)
</code></pre>

<pre><code>## [1] 2.043443e+06 4.249248e-01 4.413953e-03
</code></pre>

<pre><code class="r"># we can also use nlm and nlminb and call them from optimx
</code></pre>

</body>

</html>
