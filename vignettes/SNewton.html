<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>SNewton: safeguarded Newton methods for function minimization</title>
<style type="text/css">
/**
 * Prism.s theme ported from highlight.js's xcode style
 */
pre code {
  padding: 1em;
}
.token.comment {
  color: #007400;
}
.token.punctuation {
  color: #999;
}
.token.tag,
.token.selector {
  color: #aa0d91;
}
.token.boolean,
.token.number,
.token.constant,
.token.symbol {
  color: #1c00cf;
}
.token.property,
.token.attr-name,
.token.string,
.token.char,
.token.builtin {
  color: #c41a16;
}
.token.inserted {
  background-color: #ccffd8;
}
.token.deleted {
  background-color: #ffebe9;
}
.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
  color: #9a6e3a;
}
.token.atrule,
.token.attr-value,
.token.keyword {
  color: #836c28;
}
.token.function,
.token.class-name {
  color: #DD4A68;
}
.token.regex,
.token.important,
.token.variable {
  color: #5c2699;
}
.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}
</style>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  box-sizing: border-box;
}
body, .footnotes, code { font-size: .9em; }
li li { font-size: .95em; }
*, *:before, *:after {
  box-sizing: inherit;
}
pre, img { max-width: 100%; }
pre, pre:hover {
  white-space: pre-wrap;
  word-break: break-all;
}
pre code {
  display: block;
  overflow-x: auto;
}
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre) > code, code[class] { background-color: #F8F8F8; }
code.language-undefined, pre > code:not([class]) {
  background-color: inherit;
  border: 1px solid #eee;
}
table {
  margin: auto;
  border-top: 1px solid #666;
}
table thead th { border-bottom: 1px solid #ddd; }
th, td { padding: 5px; }
thead, tfoot, tr:nth-child(even) { background: #eee; }
blockquote {
  color: #666;
  margin: 0;
  padding-left: 1em;
  border-left: 0.5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC .numbered li { list-style: none; }
#TOC .numbered { padding-left: 0; }
#TOC .numbered ul { padding-left: 1em; }
table, .body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.footnote-ref a::before { content: "["; }
.footnote-ref a::after { content: "]"; }
.footnotes::before {
  content: "";
  display: block;
  max-width: 20em;
}

@media print {
  body {
    font-size: 12pt;
    max-width: 100%;
  }
  tr, img { page-break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  pre { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
</head>
<body>
<div class="include-before">
</div>
<div class="frontmatter">
<div class="title"><h1>SNewton: safeguarded Newton methods for function minimization</h1></div>
<div class="author"><h2>John C. Nash</h2></div>
<div class="date"><h3>2023-08-13</h3></div>
</div>
<div class="body">
<h1 id="safeguarded-newton-algorithms">Safeguarded Newton algorithms</h1>
<p>So-called <strong>Newton</strong> methods are among the most commonly mentioned in the
solution of nonlinear
equations or function minimization. However, as discussed in</p>
<p><a href="https://en.wikipedia.org/wiki/Newton%27s_method#History">https://en.wikipedia.org/wiki/Newton%27s_method#History</a>,</p>
<p>the <strong>Newton</strong> or <strong>Newton-Raphson</strong> method as we know it today was not what either of its
supposed originators knew.</p>
<p>This vignette discusses the development of simple
safeguarded variants of the Newton method for
function minimization in <strong>R</strong>. These are intended as learning tools, though the Marquardt
stabilized version appears to be quite efficient. Note that there are some resources
in <strong>R</strong> for solving
nonlinear equations by Newton-like methods in the packages <strong>nleqslv</strong> and <strong>pracma</strong>.
Also the base-R functions <strong>nlminb()</strong> and <strong>nlm()</strong> can make use of Hessians if provided,
as can tools in the <strong>trust</strong> package.</p>
<h1 id="the-basic-approach">The basic approach</h1>
<p>If we have a function of one variable \(f(x)\), with gradient \(g(x)\) and second derivative (Hessian) \(H(x)\)
the first order condition for an extremum (min or max) is</p>
<p>$$g(x) = 0$$</p>
<p>To ensure a minimum, we want</p>
<p>$$ H(x) &gt; 0 $$</p>
<p>The first order condition leads to a root-finding problem.</p>
<p>It turns out that \(x\) need not be a scalar. We can consider it to be a vector of
parameters to be determined. This renders \(g(x)\) a vector also, and \(H(x)\) a matrix.
The conditions of optimality then require a zero gradient and positive-definite Hessian.</p>
<p>The Newton approach to such
equations is to provide a guess to the root \(x_t\) and to then solve the <strong>Newton equations</strong></p>
<p>$$ H(x_t) * s = - g(x_t)$$</p>
<p>for the search vector \(s\). We update \(x_t\) to \(x_t + s\) and repeat until we have
a very small gradient \(g(x_t)\). If \(H(x)\) is positive definite, we have a reasonable
approximation to a (local) minimum.</p>
<h1 id="motivations">Motivations</h1>
<p>A particular interest in Newton-like methods are their theoretical quadratic convergence. See
<a href="https://en.wikipedia.org/wiki/Newton%27s_method">https://en.wikipedia.org/wiki/Newton%27s_method</a>.
That is, the method will converge in one step for a
quadratic function \(f(x)\), and for “reasonable”
functions will converge very rapidly. There are, however, a number
of conditions, and practical
programs need to include <strong>safeguards</strong> against mis-steps in the iterations.
Such mis-steps occur because finite-precision floating-point arithmetic incurs
errors, particularly when there are numbers of vastly different scale involved, or
else implicit assumptions such as continuity of functions or their derivatives
are not true.</p>
<p>One principal issue concerns the possibility that \(H(x)\) may not
be positive definite, at least
in some parts of the domain, and that the curvature may be such that a unit step \(x_t + s\)
does not reduce the function \(f\). We therefore get a number of possible variants of the
approach when different possible safeguards are applied, and different methods for (possibly
approximate) solution of the Newton equations are used.</p>
<h1 id="some-algorithm-possibilities">Some algorithm possibilities</h1>
<p>There are many choices we can make in building a practical code to implement the ideas
above. In tandem with the two main issues expressed above, we will consider</p>
<ul>
<li>
<p>the modification of the solution of the main equation
$$ H(x_t) * s = - g(x_t)$$ so
that a reasonable search vector \(s\) is always generated by avoiding Hessian
matrices that are not positive definite.</p>
</li>
<li>
<p>the selection of a new set of parameters \(x_{new} = x_t + step * s\) so that the
function value \(f(x_{new})\) is less than \(f(x_t)\).</p>
</li>
</ul>
<p>The second choice above could be made slightly more stringent so that the Armijo
condition  of sufficient-decrease is met.
Adding a curvature requirement gives the
Wolfe condisions. See <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">https://en.wikipedia.org/wiki/Wolfe_conditions</a>.
The Armijo requirement is generally written</p>
<p>$$f(x_t + step*s) &lt; f(x_t) + c * step * g(x_t)^T*s$$</p>
<p>where \(c\) is some number less than \(1\). Typically \(c = 1e-4 = 0.0001\). Note that the product
of gradient times search vector is negative for any reasonable situation, since we are
trying to go “downhill”.</p>
<h2 id="a-safeguarded-newton-method">A safeguarded Newton method</h2>
<p>As a result of the ideas above, the code <code>snewton()</code> uses a solution of
the Newton equations with the Hessian provided (if this is possible, else we stop),
along with a <strong>backtracking line search</strong>, where we reduce the step size until the
Armijo condition is met or terminate with the suggestion that the current \(x_t\) is
our solution. Note that @Hartley1961 suggested evaluating the function at \(x_t + s\)
and \(x_t + 0.5 * s\) to provide three values that can be used for a parabolic inverse
interpolation. However, a back-tracking search with acceptable point criterion is
generally simpler yet still effective.</p>
<h2 id="newton-marquardt-method">Newton-Marquardt method</h2>
<p>A slightly different approach in the code <code>snewtonm</code> uses a Marquardt
stabilization of the Hessian to create</p>
<p>$$ H_{aug} = H + 1_n * lambda$$</p>
<p>That is, we add \(lambda\) times the unit matrix to \(H\). Then we try the set of parameters
found by adding the solution of the Newton equations with \(H_{aug}\) in place of \(H\) to the
current “best” set of parameters. If this new set of parameters has a higher function
value than the “best” so far, we increase \(lambda\) and try again. Note that we do not
need to re-evaluate the gradient or Hessian to do this. Moreover, for some value of
large value of \(lambda\), the step is clearly almost down the gradient (i.e., steepest descents)
or we have converged and no progress is possible. This leads to a very compact and elegant
code, which we name <code>snewtonm()</code> for Safeguarded Newton-Marquardt method.
It is reliable, but may be less efficient than using the un-modified Hessian.</p>
<p>Note that it is also possible to combine the Marquardt stabilization with a line
search. Thus there is a multitude of possible methods in this general family,
which can lead to potential disagreements about which are “best” unless there
is great care taken to ensure the methods under discussion are well-defined.</p>
<h1 id="computing-the-search-vector">Computing the search vector</h1>
<p>If, when solving solving for \(s\) in the Newton equations, the Hessian is not
positive definite, we cannot apply fast and stable methods like the Cholesky
decomposition. The Newton-Marquardt for sufficiently large \(\lambda\) avoids
this difficulty.</p>
<p>However, the solution often DOES work, and we can simply try to solve, indeed,
wrapping the solution statement in the R <code>try()</code> function, and stop in the
event of failure.</p>
<h2 id="choosing-the-step-size-in-the-safeguarded-newton-method">Choosing the step size in the safeguarded Newton method</h2>
<p>The traditional Newton approach is that the stepsize is taken to be 1. In practice,
this can sometimes mean that the function value is not reduced. As an alternative,
we can use a simple backtrack search. We generally start with \(step = 1\) but it is
trivial to allow for a smaller or bigger value. Indeed, the <code>control</code> list element <code>defstep</code>
in the program <code>snewton</code> allows the initial step to be set to a value other than 1.</p>
<p>If the Armijo condition is not met, we replace \(step\) with \(r * step\)
where \(r\) is less than 1. Here we suggest <code>control$stepdec = 0.2</code>. We repeat until
\(x_t\) satisfies the Armijo condition or \(x_t\) is essentially unchanged by the step.</p>
<p>Here “essentially unchanged” is determined by a test using an offset value, that is,
the test</p>
<p>$$   (x_t + offset) == (x_t + step * d + offset) $$</p>
<p>where \(d\) is the search direction. <code>control$offset = 100</code> is used. We could
also, and almost equivalently, use the <strong>R</strong> <code>identical</code> function.</p>
<p>This approach has been coded into the <code>snewton()</code> function. Experience has
shown it to be a rather poor method.</p>
<h1 id="bounds-and-masks-constraints">Bounds and masks constraints</h1>
<p>In late 2021, the addition of bounds and masks constraints to <code>snewtonm</code> was
begun. This uses the approach described in the vignette <strong>Explaining Gradient
Minimizers in R</strong>.  The function <code>snewtonmb()</code> was developed, and it was discovered
that simply bypassing code for bounds allowed it to run about as quickly as
the original (unconstrained) <code>snewtonm()</code> routine, which it now replaces, since
there seems no merit in maintaining two routines.</p>
<p>The same ideas could be applied to <code>snewton()</code>, but my opinion is that
the Marquardt stabilization gives <code>snewtonm()</code> an advantage in reliably finding
solutions because the search direction is modified to guarantee a descent
direction in the latter code.</p>
<h1 id="examples">Examples</h1>
<p>These examples were coded as a test to the interim package <strong>snewton</strong>, but as
at 2018-7-10 are part of the <code>optimx</code> package. We call these below mostly via
the <code>optimr()</code> function,  since this lets us include the “fname” attribute in
the output of function <code>proptimr()</code>. Note that
some count information on the number of hessian evaluations and “iterations” (which
generally is an algorithm-specific measure) is not always provided.</p>
<h2 id="a-simple-example">A simple example</h2>
<p>The following example is trivial, in that the Hessian is a constant matrix,
and we achieve convergence immediately.</p>
<pre><code class="language-r"># SimpHess.R
x0&lt;-c(1,2,3,4)
lo &lt;- x0-0.5
up &lt;- x0+1.0
fnt &lt;- function(x, fscale=10){
  yy &lt;- length(x):1
  val &lt;- sum((yy*x)^2)*fscale
  val
}
attr(fnt,&quot;fname&quot;)&lt;-&quot;SimpHess&quot;
grt &lt;- function(x, fscale=10){
  nn &lt;- length(x)
  yy &lt;- nn:1
  #    gg &lt;- rep(NA,nn)
  gg &lt;- 2*(yy^2)*x*fscale
  gg
}
hesst &lt;- function(x, fscale=10){
  nn &lt;- length(x)
  yy &lt;- nn:1
  hh &lt;- diag(2*yy^2*fscale)
  hh
}

require(optimx)
t1 &lt;- optimr(x0, fnt, grt, hesst, method=&quot;snewton&quot;, control=list(trace=0, usexxxmeth=TRUE), fscale=3.0)
</code></pre>
<pre><code>## Warning in optimr(x0, fnt, grt, hesst, method = &quot;snewton&quot;, control = list(trace
## = 0, : Special controls present for optimr with method snewton
</code></pre>
<pre><code class="language-r">proptimr(t1)
</code></pre>
<pre><code>## Result  t1 ( snewton  -&gt;  (no_name) ) calc. min. = 0  at 
## 0     0     0     0     
## After  2  fn evals, and  2  gr evals and  1  hessian evals
## Termination code is  0 : Small gradient norm 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">t1m &lt;- optimr(x0, fnt, grt, hesst, method=&quot;snewtonm&quot;, control=list(trace=0), fscale=3.0)
proptimr(t1m)
</code></pre>
<pre><code>## Result  t1m ( snewtonm  -&gt;  (no_name) ) calc. min. = 2.179679e-31  at 
## 1.644772e-20     1.84828e-19     3.157948e-18     2.694731e-16     
## After  5  fn evals, and  4  gr evals and  3  hessian evals
## Termination code is  0 : snewtonm: Normal exit 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">t1nlmo &lt;- optimr(x0, fnt, grt, hess=hesst, method=&quot;nlm&quot;, fscale=3.0, 
                 control=list(trace=0))
proptimr(t1nlmo)
</code></pre>
<pre><code>## Result  t1nlmo ( nlm  -&gt;  (no_name) ) calc. min. = 8.430951e-30  at 
## -2.220446e-16     2.220446e-16     -4.440892e-16     -8.881784e-16     
## After  7  fn evals, and  7  gr evals and  7  hessian evals
## Termination code is  0 : nlm: Convergence indicator (code) =  1 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">## BUT ... nlminb may not be using a true Newton-type method
tst &lt;- try(t1nlminbo &lt;- optimr(x0, fnt, grt, hess=hesst, method=&quot;nlminb&quot;, 
                               fscale=3.0, control=list(trace=0)))

# Bounded
tstb &lt;- try(t1nlminbb &lt;- optimr(x0, fnt, grt, hess=hesst, method=&quot;nlminb&quot;, 
                lower=lo, upper=up, fscale=3.0, control=list(trace=0)))
proptimr(t1nlminbb) 
</code></pre>
<pre><code>## Result  t1nlminbb ( nlminb  -&gt;  (no_name) ) calc. min. = 184.5  at 
## 0.5 L   1.5 L   2.5 L   3.5 L   
## After  5  fn evals, and  3  gr evals and  3  hessian evals
## Termination code is  0 : relative convergence (4) 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">t1smb &lt;-  optimr(x0, fnt, grt, hess=hesst, method=&quot;snewtonm&quot;, fscale=3.0, 
                 lower=lo, upper=up, control=list(trace=0))
proptimr(t1smb)
</code></pre>
<pre><code>## Result  t1smb ( snewtonm  -&gt;  (no_name) ) calc. min. = 184.5  at 
## 0.5 L   1.5 L   2.5 L   3.5 L   
## After  6  fn evals, and  5  gr evals and  4  hessian evals
## Termination code is  0 : snewtonm: Normal exit 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r"># Masked
lo[1]&lt;-x0[1]
up[1]&lt;-x0[1]
lo[4]&lt;-x0[4]
up[4]&lt;-x0[4]
tstm &lt;- try(t1nlminbm &lt;- optimr(x0, fnt, grt, hess=hesst, method=&quot;nlminb&quot;, 
                                 lower=lo, upper=up, fscale=3.0, control=list(trace=0)))
proptimr(t1nlminbm) 
</code></pre>
<pre><code>## Result  t1nlminbm ( nlminb  -&gt;  (no_name) ) calc. min. = 231.75  at 
## 1 M   1.5 L   2.5 L   4 M   
## After  4  fn evals, and  2  gr evals and  2  hessian evals
## Termination code is  0 : relative convergence (4) 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">t1smm &lt;-  optimr(x0, fnt, grt, hess=hesst, method=&quot;snewtonm&quot;, fscale=3.0, 
                 lower=lo, upper=up, control=list(trace=0))
proptimr(t1smm)
</code></pre>
<pre><code>## Result  t1smm ( snewtonm  -&gt;  (no_name) ) calc. min. = 231.75  at 
## 1 M   1.5 L   2.5 L   4 M   
## After  4  fn evals, and  3  gr evals and  2  hessian evals
## Termination code is  0 : snewtonm: Normal exit 
## 
## -------------------------------------------------
</code></pre>
<p>From the number of hessian evaluations, it appears <code>nlminb()</code> is also
using the Hessian information. Note that the <code>snewton()</code> and <code>snewtonm()</code> functions
return count information for iterations and hessian evaluations. <code>optimr()</code> also
builds counts into internal scaled function, gradient and hessian functions, and
these are displayed by the <code>proptimr()</code> compact output function.</p>
<h2 id="the-rosenbrock-function">The Rosenbrock function</h2>
<p>Let us try our two Newton methods on the unconstrained Rosenbrock function and
compare it to some other methods that claim to use the Hessian.</p>
<pre><code class="language-r"># RosenHess.R
require(optimx)
f &lt;- function(x){ #Rosenbrock banana valley function
  return(100*(x[2] - x[1]*x[1])^2 + (1-x[1])^2)
}
attr(f,&quot;fname&quot;)&lt;-&quot;RosenHess&quot;
gr &lt;- function(x){ #gradient
  return(c(-400*x[1]*(x[2] - x[1]*x[1]) - 2*(1-x[1]), 200*(x[2] - x[1]*x[1])))
}
h &lt;- function(x) { #Hessian
  a11 &lt;- 2 - 400*x[2] + 1200*x[1]*x[1]; a21 &lt;- -400*x[1]
  return(matrix(c(a11, a21, a21, 200), 2, 2))
}
x0 &lt;- c(-1.2, 1)
t1 &lt;- snewton(x0, fn=f, gr=gr, hess=h, control=list(trace=0))
proptimr(t1)
</code></pre>
<pre><code>## Result  t1 (  -&gt;  ) calc. min. = 0  at 
## 1     1     
## After  25  fn evals, and  33  gr evals and  NA  hessian evals
## Termination code is  : Small gradient norm 
## Gradient:[1] 0 0
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r"># we can also use nlm and nlminb
fght &lt;- function(x){ ## combine f, g and h into single function for nlm
  ff &lt;- f(x)
  gg &lt;- gr(x)
  hh &lt;- h(x)
  attr(ff, &quot;gradient&quot;) &lt;- gg
  attr(ff, &quot;hessian&quot;) &lt;- hh
  ff
}

t1nlmo &lt;- optimr(x0, f, gr, hess=h, method=&quot;nlm&quot;, control=list(trace=0))
proptimr(t1nlmo)
</code></pre>
<pre><code>## Result  t1nlmo ( nlm  -&gt;  (no_name) ) calc. min. = 1.127026e-17  at 
## 1     1     
## After  36  fn evals, and  36  gr evals and  36  hessian evals
## Termination code is  0 : nlm: Convergence indicator (code) =  1 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">t1so &lt;- optimr(x0, f, gr, hess=h, method=&quot;snewton&quot;, control=list(trace=0))
proptimr(t1so)
</code></pre>
<pre><code>## Result  t1so ( snewton  -&gt;  (no_name) ) calc. min. = 0  at 
## 1     1     
## After  33  fn evals, and  25  gr evals and  24  hessian evals
## Termination code is  0 : Small gradient norm 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">t1smo &lt;-  optimr(x0, f, gr, hess=h, method=&quot;snewtonm&quot;, control=list(trace=0))
proptimr(t1smo)
</code></pre>
<pre><code>## Result  t1smo ( snewtonm  -&gt;  (no_name) ) calc. min. = 2.946445e-27  at 
## 1     1     
## After  39  fn evals, and  25  gr evals and  24  hessian evals
## Termination code is  0 : snewtonm: Normal exit 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">## nlminb 
tst &lt;- try(t1nlminbo &lt;- optimr(x0, f, gr, hess=h, method=&quot;nlminb&quot;, 
                               control=list(trace=0)))
if (class(tst) == &quot;try-error&quot;){
  cat(&quot;try-error on attempt to run nlminb in optimr()\n&quot;)
} else { proptimr(t1nlminbo) }
</code></pre>
<pre><code>## Result  t1nlminbo ( nlminb  -&gt;  (no_name) ) calc. min. = 0  at 
## 1     1     
## After  34  fn evals, and  26  gr evals and  26  hessian evals
## Termination code is  0 : X-convergence (3) 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">tstnoh &lt;- try(t1nlminbnoho &lt;- optimr(x0, f, gr, hess=NULL, method=&quot;nlminb&quot;, 
                               control=list(trace=0)))
if (class(tstnoh) == &quot;try-error&quot;){
  cat(&quot;try-error on attempt to run nlminb in optimr()\n&quot;)
} else { proptimr(t1nlminbnoho) }
</code></pre>
<pre><code>## Result  t1nlminbnoho ( nlminb  -&gt;  (no_name) ) calc. min. = 4.291966e-22  at 
## 1     1     
## After  44  fn evals, and  36  gr evals and  0  hessian evals
## Termination code is  0 : X-convergence (3) 
## 
## -------------------------------------------------
</code></pre>
<h2 id="the-wood-function">The Wood function</h2>
<p>For <code>nlm()</code> the “standard” start takes more than 100 iterations and returns
a non-optimal solution.</p>
<pre><code class="language-r">#WoodHess.R -- Wood function example
wood.f &lt;- function(x){
  res &lt;- 100*(x[1]^2-x[2])^2+(1-x[1])^2+90*(x[3]^2-x[4])^2+(1-x[3])^2+
    10.1*((1-x[2])^2+(1-x[4])^2)+19.8*(1-x[2])*(1-x[4])
  attr(res,&quot;fname&quot;)&lt;-&quot;WoodHess&quot;
  return(res)
}
wood.g &lt;- function(x){ #gradient
  g1 &lt;- 400*x[1]^3-400*x[1]*x[2]+2*x[1]-2
  g2 &lt;- -200*x[1]^2+220.2*x[2]+19.8*x[4]-40
  g3 &lt;- 360*x[3]^3-360*x[3]*x[4]+2*x[3]-2
  g4 &lt;- -180*x[3]^2+200.2*x[4]+19.8*x[2]-40
  return(c(g1,g2,g3,g4))
}
wood.h &lt;- function(x){ #hessian
  h11 &lt;- 1200*x[1]^2-400*x[2]+2;    h12 &lt;- -400*x[1]; h13 &lt;- h14 &lt;- 0
  h22 &lt;- 220.2; h23 &lt;- 0;    h24 &lt;- 19.8
  h33 &lt;- 1080*x[3]^2-360*x[4]+2;    h34 &lt;- -360*x[3]
  h44 &lt;- 200.2
  H &lt;- matrix(c(h11,h12,h13,h14,h12,h22,h23,h24,
                h13,h23,h33,h34,h14,h24,h34,h44),ncol=4)
  return(H)
}
x0 &lt;- c(-3,-1,-3,-1) # Wood standard start

require(optimx) # call methods through optimr() function
# But note that nlm default settings have lower iteration limit 
#  and in 100 &quot;iterations&quot; do not get to solution
t1nlm &lt;- optimr(x0, fn=wood.f, gr=wood.g, hess=wood.h, method=&quot;nlm&quot;)
proptimr(t1nlm)
</code></pre>
<pre><code>## Result  t1nlm ( nlm  -&gt;  wood.f ) calc. min. = 1.004941e-16  at 
## 1     1     1     1     
## After  354  fn evals, and  354  gr evals and  354  hessian evals
## Termination code is  0 : nlm: Convergence indicator (code) =  1 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r"># But both optimx Newton approaches do work
wd &lt;- optimr(x0, fn=wood.f, gr=wood.g, hess=wood.h, method=&quot;snewton&quot;)
proptimr(wd)
</code></pre>
<pre><code>## Result  wd ( snewton  -&gt;  wood.f ) calc. min. = 1.142616e-29  at 
## 1     1     1     1     
## After  119  fn evals, and  70  gr evals and  70  hessian evals
## Termination code is  92 : No progress before linesearch! 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">wdm &lt;- optimr(x0, fn=wood.f, gr=wood.g, hess=wood.h, method=&quot;snewtonm&quot;)
proptimr(wdm)
</code></pre>
<pre><code>## Result  wdm ( snewtonm  -&gt;  wood.f ) calc. min. = 6.734926e-27  at 
## 1     1     1     1     
## After  71  fn evals, and  49  gr evals and  48  hessian evals
## Termination code is  0 : snewtonm: Normal exit 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r"># nlminb 
t1nlminb &lt;- optimr(x0, fn=wood.f, gr=wood.g, hess=wood.h, method=&quot;nlminb&quot;)
proptimr(t1nlminb)
</code></pre>
<pre><code>## Result  t1nlminb ( nlminb  -&gt;  wood.f ) calc. min. = 4.79233e-29  at 
## 1     1     1     1     
## After  57  fn evals, and  45  gr evals and  45  hessian evals
## Termination code is  0 : X-convergence (3) 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">wood.fgh &lt;- function(x){
  fval &lt;- wood.f(x)
  gval &lt;- wood.g(x)
  hval &lt;- wood.h(x)
  attr(fval,&quot;gradient&quot;) &lt;- gval
  attr(fval,&quot;hessian&quot;)&lt;- hval
  fval
}

# direct call to nlm
t1nlm &lt;- nlm(wood.fgh, x0, print.level=0)
print(t1nlm)
</code></pre>
<pre><code>## $minimum
## [1] 7.874467
## 
## $estimate
## [1] -1.0316067  1.0740774 -0.9012710  0.8239815
## 
## $gradient
## [1]  0.007517820 -0.015797320 -0.008937001  0.015745111
## 
## $code
## [1] 4
## 
## $iterations
## [1] 100
</code></pre>
<pre><code class="language-r"># Check that optimr gets same result with similar iteration limit of 100
t1nlmo &lt;- optimr(x0, wood.f, wood.g, hess=wood.h, method=&quot;nlm&quot;, control=list(maxit=100))
proptimr(t1nlmo)
</code></pre>
<pre><code>## Result  t1nlmo ( nlm  -&gt;  (no_name) ) calc. min. = 7.874467  at 
## -1.031607     1.074077     -0.901271     0.8239815     
## After  106  fn evals, and  106  gr evals and  106  hessian evals
## Termination code is  1 : nlm: Convergence indicator (code) =  4 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">print(wood.g(t1nlmo$par))
</code></pre>
<pre><code>## [1]  0.007517820 -0.015797320 -0.008937001  0.015745111
</code></pre>
<pre><code class="language-r"># Run for allowed iteration limit in optimr 500*round(sqrt(npar+1)) = 1000
tst&lt;-try(t1nlminbo &lt;- optimr(x0, wood.f, wood.g, hess=wood.h, method=&quot;nlminb&quot;))
if (class(tst) == &quot;try-error&quot;){
  cat(&quot;try-error on attempt to run nlminb in optimr()\n&quot;)
} else { proptimr(t1nlminbo) }
</code></pre>
<pre><code>## Result  t1nlminbo ( nlminb  -&gt;  (no_name) ) calc. min. = 4.79233e-29  at 
## 1     1     1     1     
## After  57  fn evals, and  45  gr evals and  45  hessian evals
## Termination code is  0 : X-convergence (3) 
## 
## -------------------------------------------------
</code></pre>
<h2 id="a-generalized-rosenbrock-function">A generalized Rosenbrock function</h2>
<p>There are several generalizations of the Rosenbrock function
(e.g., \url{<a href="https://en.wikipedia.org/wiki/Rosenbrock_function#Multidimensional_generalisations%7D">https://en.wikipedia.org/wiki/Rosenbrock_function#Multidimensional_generalisations}</a>).
The following example uses the second of the Wikipedia variants.</p>
<pre><code class="language-r"># GenRoseHess.R
# genrosa function code -- attempts to match the rosenbrock at gs=100 and x=c(-1.2,1)
genrosa.f&lt;- function(x, gs=NULL){ # objective function
  ## One generalization of the Rosenbrock banana valley function (n parameters)
  n &lt;- length(x)
  if(is.null(gs)) { gs=100.0 }
  # Note do not at 1.0 so min at 0
  fval&lt;-sum (gs*(x[1:(n-1)]^2 - x[2:n])^2 + (x[1:(n-1)] - 1)^2)
}
attr(genrosa.f, &quot;fname&quot;)&lt;-&quot;genrosa&quot;

genrosa.g &lt;- function(x, gs=NULL){
  # vectorized gradient for genrose.f
  # Ravi Varadhan 2009-04-03
  n &lt;- length(x)
  if(is.null(gs)) { gs=100.0 }
  gg &lt;- as.vector(rep(0, n))
  tn &lt;- 2:n
  tn1 &lt;- tn - 1
  z1 &lt;- x[tn] - x[tn1]^2
  z2 &lt;- 1 - x[tn1]
  # f = gs*z1*z1 + z2*z2
  gg[tn] &lt;- 2 * (gs * z1)
  gg[tn1] &lt;- gg[tn1] - 4 * gs * x[tn1] * z1 - 2 *z2 
  return(gg)
}

genrosa.h &lt;- function(x, gs=NULL) { ## compute Hessian
  if(is.null(gs)) { gs=100.0 }
  n &lt;- length(x)
  hh&lt;-matrix(rep(0, n*n),n,n)
  for (i in 2:n) {
    z1&lt;-x[i]-x[i-1]*x[i-1]
    #		z2&lt;-1.0 - x[i-1]
    hh[i,i]&lt;-hh[i,i]+2.0*(gs+1.0)
    hh[i-1,i-1]&lt;-hh[i-1,i-1]-4.0*gs*z1-4.0*gs*x[i-1]*(-2.0*x[i-1])
    hh[i,i-1]&lt;-hh[i,i-1]-4.0*gs*x[i-1]
    hh[i-1,i]&lt;-hh[i-1,i]-4.0*gs*x[i-1]
  }
  return(hh)
}

require(optimx)
cat(&quot;Generalized Rosenbrock tests\n&quot;)
</code></pre>
<pre><code>## Generalized Rosenbrock tests
</code></pre>
<pre><code class="language-r">cat(&quot;original n and x0&quot;)
</code></pre>
<pre><code>## original n and x0
</code></pre>
<pre><code class="language-r">x0 &lt;- c(-1.2, 1)
# solorigs &lt;- snewton(x0, genrosa.f, genrosa.g, genrosa.h) # WORKS OK if optimx loaded
solorig &lt;- optimr(x0, genrosa.f, genrosa.g, genrosa.h, method=&quot;snewton&quot;, hessian=TRUE)

proptimr(solorig)
</code></pre>
<pre><code>## Result  solorig ( snewton  -&gt;  (no_name) ) calc. min. = 2.972526e-28  at 
## 1     1     
## After  143  fn evals, and  128  gr evals and  128  hessian evals
## Termination code is  92 : No progress before linesearch! 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">print(eigen(solorig$hessian)$values)
</code></pre>
<pre><code>## [1] 1000.400641    1.599359
</code></pre>
<pre><code class="language-r">solorigm &lt;- optimr(x0, genrosa.f, genrosa.g, genrosa.h, method=&quot;snewtonm&quot;, hessian=TRUE)
proptimr(solorigm)
</code></pre>
<pre><code>## Result  solorigm ( snewtonm  -&gt;  (no_name) ) calc. min. = 2.012939e-27  at 
## 1     1     
## After  128  fn evals, and  117  gr evals and  116  hessian evals
## Termination code is  0 : snewtonm: Normal exit 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">print(eigen(solorigm$hessian)$values)
</code></pre>
<pre><code>## [1] 1000.400641    1.599359
</code></pre>
<pre><code class="language-r"># Start with 50 values of pi and scale factor 10
x0 &lt;- rep(pi, 50)
sol50pi &lt;- optimr(x0, genrosa.f, genrosa.g, genrosa.h, method=&quot;snewton&quot;, 
                  hessian=TRUE, gs=10)
proptimr(sol50pi)
</code></pre>
<pre><code>## Result  sol50pi ( snewton  -&gt;  (no_name) ) calc. min. = 6.108742e-29  at 
## 1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     
## After  145  fn evals, and  145  gr evals and  145  hessian evals
## Termination code is  92 : No progress before linesearch! 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">print(eigen(sol50pi$hessian)$values)
</code></pre>
<pre><code>##  [1] 181.84200 181.36863 180.58176 179.48449 178.08116 176.37730 174.37964
##  [8] 172.09607 169.53560 166.70834 163.62545 160.29911 156.74243 152.96948
## [15] 148.99513 144.83509 140.50578 136.02429 131.40832 126.67610 121.84632
## [22] 116.93804 111.97066 106.96381 101.93725  96.91085  91.90447  86.93791
## [29]  82.03080  77.20253  72.47223  67.85859  63.37989  59.05387  54.89766
## [36]  50.92776  47.15992  43.60907  40.28933  37.21385  34.39481  31.84332
## [43]  29.56937  27.58175  25.88797  24.49427  23.40556  22.62547  22.15648
## [50]   2.00000
</code></pre>
<pre><code class="language-r">hhi &lt;- genrosa.h(sol50pi$par, gs=10)
print(eigen(hhi)$values)
</code></pre>
<pre><code>##  [1] 181.84200 181.36863 180.58176 179.48449 178.08116 176.37730 174.37964
##  [8] 172.09607 169.53560 166.70834 163.62545 160.29911 156.74243 152.96948
## [15] 148.99513 144.83509 140.50578 136.02429 131.40832 126.67610 121.84632
## [22] 116.93804 111.97066 106.96381 101.93725  96.91085  91.90447  86.93791
## [29]  82.03080  77.20253  72.47223  67.85859  63.37989  59.05387  54.89766
## [36]  50.92776  47.15992  43.60907  40.28933  37.21385  34.39481  31.84332
## [43]  29.56937  27.58175  25.88797  24.49427  23.40556  22.62547  22.15648
## [50]   2.00000
</code></pre>
<pre><code class="language-r">sol50pim &lt;- optimr(x0, genrosa.f, genrosa.g, genrosa.h, method=&quot;snewtonm&quot;, 
                   hessian=TRUE, gs=10)
proptimr(sol50pim)
</code></pre>
<pre><code>## Result  sol50pim ( snewtonm  -&gt;  (no_name) ) calc. min. = 1.707674e-21  at 
## 1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     
## After  115  fn evals, and  114  gr evals and  113  hessian evals
## Termination code is  0 : snewtonm: Normal exit 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">hhm &lt;- genrosa.h(sol50pim$par, gs=10)
print(eigen(hhm)$values)
</code></pre>
<pre><code>##  [1] 181.84200 181.36863 180.58176 179.48449 178.08116 176.37730 174.37964
##  [8] 172.09607 169.53560 166.70834 163.62545 160.29911 156.74243 152.96948
## [15] 148.99513 144.83509 140.50578 136.02429 131.40832 126.67610 121.84632
## [22] 116.93804 111.97066 106.96381 101.93725  96.91085  91.90447  86.93791
## [29]  82.03080  77.20253  72.47223  67.85859  63.37989  59.05387  54.89766
## [36]  50.92776  47.15992  43.60907  40.28933  37.21385  34.39481  31.84332
## [43]  29.56937  27.58175  25.88797  24.49427  23.40556  22.62547  22.15648
## [50]   2.00000
</code></pre>
<pre><code class="language-r"># Bounds constraints

lo&lt;-rep(3,50)
up&lt;-rep(4,50)
sol50pimb &lt;- optimr(x0, genrosa.f, genrosa.g, genrosa.h, lower=lo, upper=up, method=&quot;snewtonm&quot;, 
                     hessian=TRUE, gs=10)
proptimr(sol50pimb)
</code></pre>
<pre><code>## Result  sol50pimb ( snewtonm  -&gt;  (no_name) ) calc. min. = 17726  at 
## 3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3     3     3     3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3     3     3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   3 L   4 U   
## After  30  fn evals, and  29  gr evals and  28  hessian evals
## Termination code is  0 : snewtonm: Normal exit 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r"># approximate hessian
solom01 &lt;- optimr(x0, genrosa.f, gr=NULL, hess=&quot;approx&quot;, method=&quot;snewtonm&quot;, hessian=TRUE)
proptimr(solom01)
</code></pre>
<pre><code>## Result  solom01 ( snewtonm  -&gt;  (no_name) ) calc. min. = 8.606344e-21  at 
## 1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     
## After  54  fn evals, and  34  gr evals and  33  hessian evals
## Termination code is  0 : snewtonm: Normal exit 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">print(eigen(solom01$hessian)$values)
</code></pre>
<pre><code>##  [1] 1800.4213477 1795.6916212 1787.8294865 1776.8659723 1762.8443468
##  [6] 1745.8199474 1725.8599621 1703.0431647 1677.4596032 1649.2102453
## [11] 1618.4065792 1585.1701741 1549.6322004 1511.9329116 1472.2210914
## [16] 1430.6534661 1387.3940864 1342.6136796 1296.4889765 1249.2020132
## [21] 1200.9394133 1151.8916513 1102.2523007 1052.2172705 1001.9840317
## [26]  951.7508385  901.7159456  852.0768261  803.0293924  754.7672226
## [31]  707.4807973  661.3567475  616.5771185  573.3186509  531.7520834
## [36]  492.0414785  454.3435745  418.8071653  385.5725125  354.7707885
## [41]  326.5235555  300.9422818  278.1278960  258.1703833  241.1484269
## [46]  227.1290962  216.1675891  208.3070268  203.5783059    0.4987531
</code></pre>
<pre><code class="language-r">solomg1 &lt;- optimr(x0, genrosa.f, genrosa.g, hess=&quot;approx&quot;, method=&quot;snewtonm&quot;, hessian=TRUE)
proptimr(solomg1)
</code></pre>
<pre><code>## Result  solomg1 ( snewtonm  -&gt;  (no_name) ) calc. min. = 1.684908e-27  at 
## 1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     1     
## After  54  fn evals, and  34  gr evals and  33  hessian evals
## Termination code is  0 : snewtonm: Normal exit 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">print(eigen(solomg1$hessian)$values)
</code></pre>
<pre><code>##  [1] 1800.4213477 1795.6916212 1787.8294865 1776.8659723 1762.8443468
##  [6] 1745.8199474 1725.8599621 1703.0431647 1677.4596032 1649.2102453
## [11] 1618.4065792 1585.1701742 1549.6322004 1511.9329116 1472.2210914
## [16] 1430.6534661 1387.3940864 1342.6136796 1296.4889765 1249.2020132
## [21] 1200.9394133 1151.8916513 1102.2523007 1052.2172705 1001.9840317
## [26]  951.7508385  901.7159456  852.0768261  803.0293924  754.7672226
## [31]  707.4807973  661.3567475  616.5771185  573.3186509  531.7520834
## [36]  492.0414785  454.3435745  418.8071653  385.5725125  354.7707885
## [41]  326.5235555  300.9422818  278.1278960  258.1703833  241.1484269
## [46]  227.1290962  216.1675891  208.3070268  203.5783059    0.4987531
</code></pre>
<pre><code class="language-r"># Following should fail
solomrr &lt;- try(optimr(x0, genrosa.f, gr=NULL, hess=&quot;rubbish&quot;, method=&quot;snewtonm&quot;, hessian=TRUE))
</code></pre>
<pre><code>## Error in optimr(x0, genrosa.f, gr = NULL, hess = &quot;rubbish&quot;, method = &quot;snewtonm&quot;,  : 
##   Undefined character hessian -- hess =rubbish
</code></pre>
<p>Note that the above example includes an illustration of how an approximate hessian may be
invoked.</p>
<h2 id="the-hobbs-weed-infestation-problem">The Hobbs weed infestation problem</h2>
<p>This problem is described in @cnm79. It has various nasty properties. Note that one starting point causes
failure of the <code>snewton()</code> optimizer.</p>
<pre><code class="language-r"># HobbHess.R
## Optimization test function HOBBS
## Nash and Walker-Smith (1987, 1989) ...
require(optimx)

hobbs.f&lt;- function(x){ # # Hobbs weeds problem -- function
  if (abs(12*x[3]) &gt; 500) { # check computability
    fbad&lt;-.Machine$double.xmax
    return(fbad)
  }
  res&lt;-hobbs.res(x)
  f&lt;-sum(res*res)
}
attr(hobbs.f, &quot;fname&quot;)&lt;- &quot;Hobbs&quot;

hobbs.res&lt;-function(x){ # Hobbs weeds problem -- residual
  # This variant uses looping
  if(length(x) != 3) stop(&quot;hobbs.res -- parameter vector n!=3&quot;)
  y&lt;-c(5.308, 7.24, 9.638, 12.866, 17.069, 23.192, 31.443, 38.558, 50.156, 62.948,
       75.995, 91.972)
  t&lt;-1:12
  if(abs(12*x[3])&gt;50) {
    res&lt;-rep(Inf,12)
  } else {
    res&lt;-x[1]/(1+x[2]*exp(-x[3]*t)) - y
  }
}

hobbs.jac&lt;-function(x){ # Jacobian of Hobbs weeds problem
  jj&lt;-matrix(0.0, 12, 3)
  t&lt;-1:12
  yy&lt;-exp(-x[3]*t)
  zz&lt;-1.0/(1+x[2]*yy)
  jj[t,1] &lt;- zz
  jj[t,2] &lt;- -x[1]*zz*zz*yy
  jj[t,3] &lt;- x[1]*zz*zz*yy*x[2]*t
  return(jj)
}

hobbs.g&lt;-function(x){ # gradient of Hobbs weeds problem
  # NOT EFFICIENT TO CALL AGAIN
  jj&lt;-hobbs.jac(x)
  res&lt;-hobbs.res(x)
  gg&lt;-as.vector(2.*t(jj) %*% res)
  return(gg)
}


hobbs.rsd&lt;-function(x) { # Jacobian second derivative
  rsd&lt;-array(0.0, c(12,3,3))
  t&lt;-1:12
  yy&lt;-exp(-x[3]*t)
  zz&lt;-1.0/(1+x[2]*yy)
  rsd[t,1,1]&lt;- 0.0
  rsd[t,2,1]&lt;- -yy*zz*zz
  rsd[t,1,2]&lt;- -yy*zz*zz
  rsd[t,2,2]&lt;- 2.0*x[1]*yy*yy*zz*zz*zz
  rsd[t,3,1]&lt;- t*x[2]*yy*zz*zz
  rsd[t,1,3]&lt;- t*x[2]*yy*zz*zz
  rsd[t,3,2]&lt;- t*x[1]*yy*zz*zz*(1-2*x[2]*yy*zz)
  rsd[t,2,3]&lt;- t*x[1]*yy*zz*zz*(1-2*x[2]*yy*zz)
  ##    rsd[t,3,3]&lt;- 2*t*t*x[1]*x[2]*x[2]*yy*yy*zz*zz*zz
  rsd[t,3,3]&lt;- -t*t*x[1]*x[2]*yy*zz*zz*(1-2*yy*zz*x[2])
  return(rsd)
}

hobbs.h &lt;- function(x) { ## compute Hessian
  #   cat(&quot;Hessian not yet available\n&quot;)
  #   return(NULL)
  H&lt;-matrix(0,3,3)
  res&lt;-hobbs.res(x)
  jj&lt;-hobbs.jac(x)
  rsd&lt;-hobbs.rsd(x)
  ##    H&lt;-2.0*(t(res) %*% rsd + t(jj) %*% jj)
  for (j in 1:3) {
    for (k in 1:3) {
      for (i in 1:12) {
        H[j,k]&lt;-H[j,k]+res[i]*rsd[i,j,k]
      }
    }
  }
  H&lt;-2*(H + t(jj) %*% jj)
  return(H)
}

x0 &lt;- c(200, 50, .3)
cat(&quot;Good start for Hobbs:&quot;)
</code></pre>
<pre><code>## Good start for Hobbs:
</code></pre>
<pre><code class="language-r">print(x0)
</code></pre>
<pre><code>## [1] 200.0  50.0   0.3
</code></pre>
<pre><code class="language-r">solx0 &lt;- optimr(x0, hobbs.f, hobbs.g, hobbs.h, method=&quot;snewton&quot;, hessian=TRUE)
## Note that we exceed count limit, but have answer
proptimr(solx0)
</code></pre>
<pre><code>## Result  solx0 ( snewton  -&gt;  (no_name) ) calc. min. = 2.587277  at 
## 196.1863     49.09164     0.3135697     
## After  9  fn evals, and  9  gr evals and  9  hessian evals
## Termination code is  92 : No progress before linesearch! 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">print(eigen(solx0$hessian)$values)
</code></pre>
<pre><code>## [1] 2.043443e+06 4.249248e-01 4.413953e-03
</code></pre>
<pre><code class="language-r">## Note that we exceed count limit, but have answer

## Setting relative check offset larger gets quicker convergence
solx0a &lt;- optimr(x0, hobbs.f, hobbs.g, hobbs.h, method=&quot;snewton&quot;, 
                  control=list(offset=1000.))
</code></pre>
<pre><code>## Warning in optimr(x0, hobbs.f, hobbs.g, hobbs.h, method = &quot;snewton&quot;, control =
## list(offset = 1000)): Special controls present for optimr with method snewton
</code></pre>
<pre><code class="language-r">proptimr(solx0a)
</code></pre>
<pre><code>## Result  solx0a ( snewton  -&gt;  (no_name) ) calc. min. = 2.587277  at 
## 196.1863     49.09164     0.3135697     
## After  9  fn evals, and  9  gr evals and  9  hessian evals
## Termination code is  92 : No progress before linesearch! 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">x1s &lt;- c(100, 10, .1)
cat(&quot;Scaled start for Hobbs:&quot;)
</code></pre>
<pre><code>## Scaled start for Hobbs:
</code></pre>
<pre><code class="language-r">print(x1s)
</code></pre>
<pre><code>## [1] 100.0  10.0   0.1
</code></pre>
<pre><code class="language-r">solx1s &lt;- optimr(x1s, hobbs.f, hobbs.g, hobbs.h, method=&quot;snewton&quot;, hessian=TRUE , control=list(trace=0))
proptimr(solx1s)
</code></pre>
<pre><code>## Result  solx1s ( snewton  -&gt;  (no_name) ) calc. min. = 2.587277  at 
## 196.1863     49.09164     0.3135697     
## After  1010  fn evals, and  1001  gr evals and  1000  hessian evals
## Termination code is  1 : Snewton - no msg 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">print(eigen(solx1s$hessian)$values)
</code></pre>
<pre><code>## [1] 2.043443e+06 4.249248e-01 4.413953e-03
</code></pre>
<pre><code class="language-r">solx1m &lt;- optimr(x1s, hobbs.f, hobbs.g, hobbs.h, method=&quot;snewtonm&quot;, hessian=TRUE , control=list(trace=0))
proptimr(solx1m)
</code></pre>
<pre><code>## Result  solx1m ( snewtonm  -&gt;  (no_name) ) calc. min. = 2.587277  at 
## 196.1863     49.09164     0.3135697     
## After  26  fn evals, and  23  gr evals and  22  hessian evals
## Termination code is  0 : snewtonm: Normal exit 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">print(eigen(solx1m$hessian)$values)
</code></pre>
<pre><code>## [1] 2.043443e+06 4.249248e-01 4.413953e-03
</code></pre>
<pre><code class="language-r">cat(&quot;Following test fails in snewton with ERROR \n
     -- Not run as function infinite.\n&quot;)
</code></pre>
<pre><code>## Following test fails in snewton with ERROR 
## 
##      -- Not run as function infinite.
</code></pre>
<pre><code class="language-r">x3 &lt;- c(1, 1, 1)
# solx3 &lt;- try(optimr(x3, hobbs.f, hobbs.g, hobbs.h, method=&quot;snewton&quot;, control=list(trace=4)))
# if ((solx3$convergence != 0) || class(solx3) != &quot;try-error&quot;) {
#   proptimr(solx3)
#   print(eigen(solx3$hessian)$values)
# }
# dirx3 &lt;- try(snewton(x3, hobbs.f, hobbs.g, hobbs.h, control=list(trace=4)))
# if ((dirx3$convergence != 0) || class(dirx3) != &quot;try-error&quot;) {
#   proptimr(dirx3)
#   print(eigen(dirx3$Hess)$values)
# }
cat(&quot;But Marquardt variant succeeds\n&quot;)
</code></pre>
<pre><code>## But Marquardt variant succeeds
</code></pre>
<pre><code class="language-r">solx3m &lt;- optimr(x3, hobbs.f, hobbs.g, hobbs.h, method=&quot;snewtonm&quot;, 
                  hessian=TRUE, control=list(trace=0))
proptimr(solx3m)
</code></pre>
<pre><code>## Result  solx3m ( snewtonm  -&gt;  (no_name) ) calc. min. = 2.587277  at 
## 196.1863     49.09164     0.3135697     
## After  35  fn evals, and  24  gr evals and  23  hessian evals
## Termination code is  0 : snewtonm: Normal exit 
## 
## -------------------------------------------------
</code></pre>
<pre><code class="language-r">print(eigen(solx3m$hessian)$values)
</code></pre>
<pre><code>## [1] 2.043443e+06 4.249248e-01 4.413953e-03
</code></pre>
<pre><code class="language-r"># we could also use nlm and nlminb and call them from optimr

solx3 &lt;- try(optimr(x3, hobbs.f, hobbs.g, hobbs.h, method=&quot;snewton&quot;, control=list(trace=0)))
</code></pre>
<pre><code>## Error in snewton(par = spar, fn = efn, gr = egr, hess = ehess, control = mcontrol) : 
##   Cannot compute gradient projection
</code></pre>
<pre><code class="language-r">if ((class(solx3) != &quot;try-error&quot;) &amp;&amp; (solx3$convergence == 0)) {
  proptimr(solx3)
  print(eigen(solx3$hessian)$values)
} else cat(&quot;solx3 failed!\n&quot;)
</code></pre>
<pre><code>## solx3 failed!
</code></pre>
<pre><code class="language-r">dirx3 &lt;- try(snewton(x3, hobbs.f, hobbs.g, hobbs.h, control=list(trace=0)))
if ((class(dirx3) != &quot;try-error&quot;) &amp;&amp; (dirx3$convcode == 0)) {
  proptimr(dirx3)
  print(eigen(dirx3$Hess)$values)
} else cat(&quot;dirx3 failed!\n&quot;)
</code></pre>
<pre><code>## dirx3 failed!
</code></pre>
<h1 id="an-assessment">An assessment</h1>
<p>In a number of tests, in particular using the tests in @Melville18, the ‘snewton()’
approach is far from satisfactory. This is likely because the search direction computed
cannot adapt to find lower function values when the Hessian is near singular. In fact,
I do not include this approach in the “all methods” control in the function ‘optimx::opm()’.</p>
<p>On the other hand, ‘snewtonm()’ generally works reasonably well, though it is an open question
whether the gain in information in using the Hessian contributes to better solutions or
better efficiency in optimization.</p>
<h2 id="references">References</h2>
</div>
<div class="include-after">
</div>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/combine/npm/katex/dist/katex.min.js,npm/katex/dist/contrib/auto-render.min.js,npm/@xiee/utils/js/render-katex.js" defer></script>
</body>
</html>
